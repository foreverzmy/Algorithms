# 排序算法

## 算法对比

![](./images/clipboard.png)

**说明**

1. 对于评述算法优劣术语的说明

   稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面;

   不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面;

   内排序：所有排序操作都在内存中完成;

   外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行;

   时间复杂度：一个算法执行所消耗的时间;

   空间复杂度：运算完一个程序所需内存的大小;

2. 名词解释

   n：数据规模

   k：“桶”的个数

   In-place：内排序

   Out-place：外排序

## 冒泡排序 Bubble Sort

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的书序错误就把它们交换过来。重复的走访直到再没有需要交换，也就是说该数列已经排序完成。这个算法的名字又来是因为越小的元素会经由交换慢慢的“浮”到数列的前端。

### 描述和实现

* 基本冒泡算法

  1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个;
  2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数;
  3. 针对所有的元素重复以上的步骤，除了最后一个;
  4. 重复步骤 1~3，直到排序完成;

* 算法改进 1

  设置一标志性变量 pos,用于记录每趟排序中最后一次进行交换的位置;

  由于 pos 位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到 pos 位置即可，如果有一趟排序中没有产生交换的话，pos 为 0，那么说明此刻数列以及变成了有序数列;

* 算法改进 2

  传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值，我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次，可以得到两个最终值(最大者和最小者),从而使排序趟数几乎减少了一半

实现见代码 [bubble_sort.py](./bubble_sort.py)

### 动图演示

![](./images/bubble_sort.gif)

### 复杂度分析

* 最佳情况：T(n)=O(n²) 或 T(n)=O(n)

  当输入的数据已经是正序时是最佳情况。

  在第一种算法中，时间复杂度为 `n+(n-1)+(n-2)+……+1=n(n-1)/2`，复杂度为 `O(n²)`;

  在第二种算法中有一个标志位，如果有一趟排序中没有产生交换的话，标志位为 0，那么说明此刻数列已经变成了有序的数列，会跳出循环。如果是正序的话，会直接遍历一遍，不产生交换，标志位为 0，直接跳出循环，所以复杂度为 `O(n)`;

* 最差情况：T(n)=O(n²)

  当输入的数列是反序时，两种算法都需要遍历数列并交换，时间复杂度都为 `n(n-1)/2`，即 `O(n²)`;

* 平均情况：T(n)=O(n²)

## 选择排序 Selection Sort

选择排序是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

无论什么数据进去都是 `O(n²)` 的时间复杂度，所以用到它的时候，数据规模越小越好。

### 描述和实现

n 个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下：

1. 初始状态：无序区为 R[1..n]，有序区为空；
2. 第 i 趟排序 (i=1,2,3...n-1) 开始时，当前有序区和无序区分别为 R[1..i-1] 和 R(i..n）。该趟排序从当前无序区中找出最小的记录 R[k]，将它与无序区的第 1 个记录 R 交换，使 R[1..i] 和 R[i+1..n) 分别变为记录个数增加 1 个的新有序区和记录个数减少 1 个的新无序区；
3. n-1 趟结束，数组有序化了。

实现见代码 [selection_sort.py](./selection_sort.py)

### 动图演示

![](./images/selection_sort.gif)

### 复杂度分析

选择排序只有一种情况，`T(n) = O(n²)`。

外层会从头到倒数第二位遍历一遍，内层会遍历一遍无序区，所以时间复杂度为 `(n-1)((n-1)+(n-2)+……+2+1)=n(n-1)/2`，即 `O(n²)`;

## 插入排序 Insertion Sort

插入排序的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

插入排序和打扑克牌时摸牌有点类似，从一堆无序的牌中拿出最上面一张，然后从后往前对比，找到合适的位置插入。

### 描述和实现

一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：

* 基本插入排序

  1. 从第一个元素开始，该元素可以认为已经被排序；
  2. 取出下一个元素，在已经排序的元素序列中从后向前扫描；
  3. 如果该元素（已排序）大于新元素，将该元素移到下一位置；
  4. 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
  5. 将新元素插入到该位置后；
  6. 重复步骤 2~5。

* 二分法插入排序

  1. 从第一个元素开始，该元素可以认为已经被排序；
  2. 取出下一个元素，将取出的元素与已排序区的中间值比较;
  3. 找出元素所在区间;
  4. 重复以上步骤，直到区间只剩两个数值;
  5. 将取出元素插入到区间中;
  6. 重复步骤 2~5。

实现见代码 [insertion_sort.py](./insertion_sort.py)

### 动图演示

![](./images/insertion_sort.gif)

### 复杂度分析

* 最佳情况：T(n) = O(n)

  当使用第一种算法时，当输入数列是正序时最佳。取出的数直接与有序区的最后一位比较，是大于最后一位的，直接排在后面，所以直接遍历一遍即可，复杂度为 `O(n)`;

  而当使用二分法插入排序时，最佳情况是当插入的位置刚好是二分位置，复杂度为 `O(n)`。

* 最坏情况：T(n) = O(n²)

  当输入数列是反序时最坏。

  当使用第一种算法时，取出的数要遍历一遍有序区才能找到位置插入，所以复杂度为 `(n-1)(1+2+3+……+(n-1))=n(n-1)/2`，即 `O(n²)`;

  当使用二分法插入排序时，外循环从 1 开始遍历，内循环用二分法查找插入，所以时间复杂度为 `(n-1)((2log₂1+1)+(2log₂2+1)+……+(2log₂(n)+1))=n²-2n+2(n-1)log₂n(n!)+1`，即 `O(n²)`。

* 平均情况：T(n) = O(n²)

## 希尔排序 Shell Sort

希尔排序是插入排序的一种更高效率的实现。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。

### 描述和实现

将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

1. 选择一个增量序列 t1，t2，…，tk，其中 ti>tj，tk=1；
2. 按增量序列个数 k，对序列进行 k 趟排序；
3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度

实现见代码 [shell_sort.py](./shell_sort.py)

### 图片演示

![](./images/shell_sort.png)

### 复杂度分析

* 最佳情况：T(n) = O(nlog₂n)

* 最坏情况：T(n) = O(nlog₂n)

* 平均情况：T(n) = O(nlog₂n)

## 归并排序 Merge Sort

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并。

### 描述和实现

作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：

    1. 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第2种方法）;
    2. 自下而上的迭代;

自上而下的迭代算法如下：

    1. 把长度为n的输入序列分成两个长度为n/2的子序列；
    2. 对这两个子序列分别采用归并排序；
    3. 将两个排序好的子序列合并成一个最终的排序序列。

实现见代码 [merge_sort.py](./merge_sort.py)

### 图片演示

![](./images/merge_sort.png)

### 复杂度分析

和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 `O(nlog₂n)` 的时间复杂度。代价是需要额外的内存空间。

* 最佳情况：T(n) = O(n)
* 最差情况：T(n) = O(nlog₂n)
* 平均情况：T(n) = O(nlog₂n)

## 快速排序 Quick Sort

又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高! 它是处理大数据最快的排序算法之一了。

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

### 描述和实现

* 快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

  1. 从数列中挑出一个元素，称为 "基准"（pivot）；
  2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
  3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

* 还有一种改进算法：

  1. 以中间值作为基准，并将其取出;
  2. 遍历数组，将小于基准的数放入左数组，大于基准的数放入右数组;
  3. 递归调用 1，2 两部，直至每个数组的长度不大于 1;
  4. 递归时拼接长度不大于 1 的数组;

实现见代码 [quick_sort.py](./quick_sort.py)

### 动图演示

![](./images/quick_sort.gif)

### 复杂度分析

    * 最佳情况：T(n) = O(nlog₂n)
    * 最差情况：T(n) = O(n²)
    * 平均情况：T(n) = O(nlog₂n)

快速排序的最坏运行情况是 `O(n²)`，比如说顺序数列的快排。但它的平摊期望时间是 `O(nlog₂n)` ，且 `O(nlog₂n)` 记号中隐含的常数因子很小，比复杂度稳定等于 `O(nlog₂n)` 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。

## 堆排序 Heap Sort

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

### 描述和实现

堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：

    * 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列;
    * 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列;

具体算法描述如下：

    1. 将初始待排序关键字序列 (R1,R2....Rn) 构建成大顶堆，此堆为初始的无序区；
    2. 将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区 (R1,R2,......Rn-1) 和新的有序区 (Rn) ,且满足 R[1,2...n-1]<=R[n]；
    3. 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区 (R1,R2,......Rn-1) 调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区 (R1,R2....Rn-2) 和新的有序区 (Rn-1,Rn)。不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成。

实现见代码 [heap_sort.py](./heap_sort.py)

### 动图演示

![](./images/heap_sort.gif)

### 复杂度分析

* 最佳情况：T(n) = O(nlog₂n)
* 最差情况：T(n) = O(nlog₂n)
* 平均情况：T(n) = O(nlog₂n)

## 计数排序 Counting Sort

计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组 C，其中第 i 个元素是待排序数组 A 中值等于 i 的元素的个数。然后根据数组 C 来将 A 中的元素排到正确的位置。它只能对整数进行排序。

### 描述和实现

计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。
作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

1. 找出待排序的数组中最大和最小的元素；
2. 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；
3. 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；
4. 反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去1。

实现见代码 [counting_sort.py](./counting_sort.py)

### 动图演示

![](./images/counting_sort.gif)

### 复杂度分析

当输入的元素是n 个 0~k 之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 C 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。

* 最佳情况：T(n) = O(n+k)
* 最差情况：T(n) = O(n+k)
* 平均情况：T(n) = O(n+k)

## 桶排序 Bucket Sort

桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。
为了使桶排序更加高效，我们需要做到这两点：
    1. 在额外空间充足的情况下，尽量增大桶的数量
    2. 使用的映射函数能够将输入的N个数据均匀的分配到K个桶中
同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。

### 描述和实现

桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序。

1. 设置一个定量的数组当作空桶；
2. 遍历输入数据，并且把数据一个一个放到对应的桶里去；
3. 对每个不是空的桶进行排序；
4. 从不是空的桶里把排好序的数据拼接起来。

### 动图演示

略

### 复杂度分析

桶排序最好情况下使用线性时间 `O(n)`，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 `O(n)`。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。

* 最佳情况：T(n) = O(n+k)

    当输入的数据可以均匀的分配到每一个桶中

* 最差情况：T(n) = O(n+k)

    当输入的数据被分配到了同一个桶中

* 平均情况：T(n) = O(n²)

## 基数排序 Radix Sort

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。

### 描述和实现

基数排序有两种方法：

    1. MSD 从高位开始进行排序
    2. LSD 从低位开始进行排序

这里我使用的是 LSD：

1. 取得数组中的最大数，并取得位数；
2. arr为原始数组，从最低位开始取每个位组成radix数组；
3. 对radix进行计数排序（利用计数排序适用于小范围数的特点）；

### 动图演示

### 复杂度分析

* 最佳情况：T(n) = O(n*k)
* 最差情况：T(n) = O(n*k)
* 平均情况：T(n) = O(n*k)

## 基数排序 vs 计数排序 vs 桶排序

这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：
    * 基数排序：根据键值的每位数字来分配桶
    * 计数排序：每个桶只存储单一键值
    * 桶排序：每个桶存储一定范围的数值