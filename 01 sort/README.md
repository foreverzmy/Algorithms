# 排序算法

## 算法对比

![](./images/clipboard.png)

**说明**

1. 对于评述算法优劣术语的说明

    稳定：如果 a 原本在 b 前面，而 a=b，排序之后 a 仍然在 b 的前面;

    不稳定：如果 a 原本在 b 的前面，而 a=b，排序之后 a 可能会出现在 b 的后面;

    内排序：所有排序操作都在内存中完成;

    外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行;

    时间复杂度：一个算法执行所消耗的时间;

    空间复杂度：运算完一个程序所需内存的大小;

2. 名词解释

    n：数据规模

    k：“桶”的个数

    In-place：内排序

    Out-place：外排序

## 冒泡排序 Bubble Sort

### 算法描述

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的书序错误就把它们交换过来。重复的走访直到再没有需要交换，也就是说该数列已经排序完成。这个算法的名字又来是因为越小的元素会经由交换慢慢的“浮”到数列的前端。

### 描述和实现

* 基本冒泡算法

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个;
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数;
3. 针对所有的元素重复以上的步骤，除了最后一个;
4. 重复步骤1~3，直到排序完成;

* 算法改进 1

    设置一标志性变量 pos,用于记录每趟排序中最后一次进行交换的位置;

    由于 pos 位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可，如果有一趟排序中没有产生交换的话，pos 为 0，那么说明此刻数列以及变成了有序数列;

* 算法改进 2

    传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值，我们考虑利用在每趟排序中进行正向和反向两遍冒泡的方法一次，可以得到两个最终值(最大者和最小者),从而使排序趟数几乎减少了一半


实现见代码 [bubble_sort.py](./bubble_sort.py)

### 算法分析

* 最佳情况：T(n)=O(n<sup>2</sup>) 或 T(n)=O(n)

    当输入的数据已经是正序时是最佳情况。
    
    在第一种算法中，时间复杂度为 `n+(n-1)+(n-2)+……+1=n(n-1)/2`，复杂度为 `O(n<sup>2</sup>)`;
    
    在第二种算法中有一个标志位，如果有一趟排序中没有产生交换的话，标志位为 0，那么说明此刻数列已经变成了有序的数列，会跳出循环。如果是正序的话，会直接遍历一遍，不产生交换，标志位为 0，直接跳出循环，所以复杂度为 `O(n)`;

* 最差情况：T(n)=O(n<sup>2</sup>)

    当输入的数列是反序时，两种算法都需要遍历数列并交换，时间复杂度都为 `n(n-1)/2`，即 O(n<sup>2</sup>);

* 平均情况：T(n)=O(n<sup>2</sup>)

## 选择排序 Selection Sort

